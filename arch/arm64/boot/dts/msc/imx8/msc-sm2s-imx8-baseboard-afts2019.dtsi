/** @file      msc-sm2s-imx8-baseboard-afts2019.dtsi

    @copyright Copyright (C) 2021 by MSC Technologies GmbH
    SPDX-License Identifier: GPL-2.0-or-later

    @author    Markus Pietrek

    @details   Provides baseboard mappings that are merged at runtime with the CPU device tree.
*/

/dts-v1/;
/plugin/;

#include <dt-bindings/firmware/imx/rsrc.h>
#include <dt-bindings/gpio/gpio.h>
#include <dt-bindings/input/input.h>
#include <dt-bindings/pinctrl/pads-imx8qm-pintool-compatible.h>

/* USB mapping on AFTS2019
   | SM2 Port        | AFTS Connector                                                       | i.MX8 24N06E1I             | i.MX8 2406A0I |
   |-----------------|----------------------------------------------------------------------|----------------------------|---------------|
   | USB0            | Host Mode: X0704, Device Mode: X0705 (*1)                            | USB_OTG1                    | X             |
   | USB1            | X0701 (*1)                                                           | Hub U1001/USB_OTG2         | X             |
   | USB2, USB2_SSTX | Host Mode: X0707 (SS), X0706 (HS) (*2)                               | Hub U1001/USB_OTG2/USB_SS3 | X             |
   | USB3, USB3_SSTX | Host Mode: X0711 (SS), X0710 (HS) (*2), Device Mode: X0709 and X0708 |                                           | n.c.                       | n.c.          |
   | USB4            | X0702 (HS)                                                           | Hub U1001                  | X             |

   *1: IOW_USB0_USB1_LOOP=False otherwise internal loopback is used
       IOW_USB0_OTG_ID controls device or host mode
   *2: IOW_USB2_USB3_LOOP=False otherwise internal loopback is used
*/

/ {
	fragment@0 {
		target-path = "/";

		__overlay__ {
			baseboard-dtb = "MSC-AFTS2019-DV1"; /* just informal */
		};
	};

	fragment@1 {
		target = <&regulators>;
		__overlay__ {
			reg_vcc_3v3_aud: vcc_3v3_aud_regulator {
				compatible = "regulator-fixed";
				regulator-name = "3V3_AUD";
				regulator-min-microvolt = <3300000>;
				regulator-max-microvolt = <3300000>;
			};

			reg_vcc_1v8_aud: vcc_1v8_aud_regulator {
				compatible = "regulator-fixed";
				regulator-name = "1V8_AUD";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <1800000>;
			};
		};
	};

	fragment@2 {
		target = <&i2c2>;
		__overlay__ {
			#address-cells = <1>;
			#size-cells = <0>;
			sgtl5000_codec: sgtl5000@a {
				compatible = "fsl,sgtl5000";
				reg = <0x0a>;
				pinctrl-names = "default";
				pinctrl-0 = <&pinctrl_audio_mclk>;

				clocks = <&mclkout0_lpcg 0>;
				clock-names = "mclk";
				assigned-clocks = <&clk IMX_SC_R_AUDIO_PLL_0 IMX_SC_PM_CLK_PLL>,
					<&clk IMX_SC_R_AUDIO_PLL_0 IMX_SC_PM_CLK_SLV_BUS>,
					<&clk IMX_SC_R_AUDIO_PLL_0 IMX_SC_PM_CLK_MST_BUS>,
					<&mclkout0_lpcg 0>;

				assigned-clock-rates = <786432000>, <49152000>, <12288000>;
				VDDA-supply = <&reg_vcc_3v3_aud>;
				VDD-supply = <&reg_vcc_1v8_aud>;
				VDDIO-supply = <&reg_vcc_1v8_aud>;
			};
		};
	};

	fragment@3 {
		target = <&sai1>;
		__overlay__ {
			pinctrl-names = "default";
			pinctrl-0 = <&pinctrl_i2s0>;
			status = "okay";
		};
	};

	fragment@4 {
		target-path = "/";
		__overlay__ {
			sgtl5000_sound: sgtl5000-sound {
				compatible = "fsl,imx-audio-sgtl5000";
				fsl,no-audmux;
				ssi-controller = <&sai1>;
				audio-codec = <&sgtl5000_codec>;
				model = "imx-sgtl5000";
				audio-routing =
						"LINE_IN", "Line In Jack",
						"MIC_IN", "Mic Jack",
						"Mic Jack", "Mic Bias",
						"Headphone Jack", "HP_OUT";
			};
		};
	};

	fragment@5 {
		target = <&i2c1>; /* i2c_pm */
		__overlay__ {
			#address-cells = <1>;
			#size-cells = <0>;
			baseboard_eeprom@57 {
				compatible = "atmel,24c64";
				reg = <0x57>;
			};
		};
	};

	fragment@6 {
		target = <&i2c2>; /* i2c_gp */
		__overlay__ {
			#address-cells = <1>;
			#size-cells = <0>;
			pca9541a_u0502@70 {
				compatible = "nxp,pca9541";
				reg = <0x70>; /* S0503 must be set all to on */

				i2c_arb: i2c-arb {
					#address-cells = <1>;
					#size-cells = <0>;

					adc@35 {
						compatible = "maxim,max1139";
						reg = <0x35>;
					};

					eeprom@54 {
						compatible = "atmel,24c64";
						reg = <0x54>;
					};

					fpga_u0801@74 {
						compatible = "msc,afts2019_fpga";
						reg = <0x74>;
					};
				};
			};
		};
	};

	fragment@7 {
		target-path = "/";
		__overlay__ {
			i2c_ids {
				i2c_thw {
					label = "thw";
					bus = <&i2c_arb>;
				};
			};
		};
	};

	fragment@8 {
		target = <&lpspi1>;
		__overlay__ {
			#address-cells = <1>;
			#size-cells = <0>;

			flash_spi0: w25q64dw_u0604@0 { // this one is socketed
				reg = <0>;
				#address-cells = <1>;
				#size-cells = <1>;
				compatible = "jedec,spi-nor";
				spi-max-frequency = <20000000>;
				spi-tx-bus-width = <1>;
				spi-rx-bus-width = <1>;
			};

			flash_spi1: w25q64dw_u0603@1 {
				reg = <1>;
				#address-cells = <1>;
				#size-cells = <1>;
				compatible = "jedec,spi-nor";
				spi-max-frequency = <20000000>;
				spi-tx-bus-width = <1>;
				spi-rx-bus-width = <1>;
			};
		};
	};

	fragment@9 {
		target = <&lpspi3>;
		__overlay__ {
			#address-cells = <1>;
			#size-cells = <0>;
			flash_espi0: w25q64dw_u0605@0 {
				reg = <0>;
				#address-cells = <1>;
				#size-cells = <1>;
				compatible = "jedec,spi-nor";
				spi-max-frequency = <20000000>;
				spi-tx-bus-width = <1>;
				spi-rx-bus-width = <1>;
			};
			flash_espi1: w25q64dw_u0606@1 {
				reg = <1>;
				#address-cells = <1>;
				#size-cells = <1>;
				compatible = "jedec,spi-nor";
				spi-max-frequency = <20000000>;
				spi-tx-bus-width = <1>;
				spi-rx-bus-width = <1>;
			};
		};
	};

	fragment@10 {
		target-path = "/";
		__overlay__ {
			user_gpios {
				compatible = "msc,user-gpios";
				pinctrl-names = "default";
				pinctrl-0 =
					<&pinctrl_smarc_gpio_gpio5_gpio>, // FAN is not connected, so configure pins as GPIOs even when we don't connect them to feature connector
					<&pinctrl_smarc_gpio_gpio6_gpio>; // should be couting pulses, but pins is neither connected to GPT nor TPM

				GPIO_0-gpios = <&lsio_gpio0 0 0>;
				GPIO_1-gpios = <&lsio_gpio0 2 0>;
				GPIO_2-gpios = <&lsio_gpio0 1 0>;
				GPIO_3-gpios = <&lsio_gpio0 5 0>;
				GPIO_4-gpios = <&lsio_gpio4 2 0>;
				GPIO_5-gpios = <&lsio_gpio0 19 0>;
				GPIO_6-gpios = <&lsio_gpio0 16 0>;
				GPIO_7-gpios = <&lsio_gpio4 1 0>;
#if MODULE_MES_REVISION != 20
				GPIO_8-gpios = <&lsio_gpio2 27 0>;
				GPIO_9-gpios = <&lsio_gpio1 18 0>;
				GPIO_10-gpios = <&lsio_gpio2 29 0>;
				GPIO_11-gpios = <&lsio_gpio1 17 0>;

				RSVD_09-gpios = <&lsio_gpio1 13 0>; /* GPIO_12 on SMARC 2.1.1 */
				RSVD_08-gpios = <&lsio_gpio1 7 0>; /* GPIO_13 on SMARC 2.1.1 */
#else
				GPIO_8-gpios = <&lsio_gpio0 30 0>;
				GPIO_9-gpios = <&lsio_gpio0 31 0>;
				GPIO_10-gpios = <&lsio_gpio1 0 0>;
				GPIO_11-gpios = <&lsio_gpio1 1 0>;
#endif

				/* FPGA names are provided directly by afts2019_fpga_gpios.c */
			};
		};
	};

	fragment@11 {
		target-path = "/";
		__overlay__ {
			gpio-keys {
				compatible = "gpio-keys";
				pinctrl-names = "default";
				pinctrl-0 = <&pinctrl_gpio_keys>;

				sleep-key {
					label = "BTN SLEEP"; // signal SLEEP#
					gpios = <&lsio_gpio2 5 GPIO_ACTIVE_LOW>;
					linux,code = <KEY_SLEEP>;
					linux,can-disable;
					debounce-interval = <5>;
				};

				lid-switch {
					label = "BTN LID"; // signal LID#
					gpios = <&lsio_gpio2 4 GPIO_ACTIVE_LOW>;
					linux,input-type = <EV_SW>;
					linux,code = <SW_LID>;
					linux,can-disable;
					debounce-interval = <5>;
					wakeup-source;
				};
			};
		};
	};
};
